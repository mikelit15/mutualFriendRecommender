# -*- coding: utf-8 -*-
"""Homework 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O4dSbGWA3c-2g-a3aFe_OV19nrWK7lTG
"""

## By Michael Litvn, WORKED WITH JASON HAYNBERG AND TIM STUMPER

# Setup code, must be run before assignment code
!pip install pyspark
!pip install -U -q PyDrive
!apt install openjdk-8-jdk-headless -qq
import os
os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

# Authenticate and create the PyDrive client
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)
id='1_gN7tIhxOkW6bAhQ_iUxm_bTKI2ulumq'
downloaded = drive.CreateFile({'id': id})
downloaded.GetContentFile('soc-LiveJournal1Adj.txt')
from pyspark.sql import *
from pyspark.sql.functions import *
from pyspark import SparkContext
import pandas as pd

# create the Spark Session
spark = SparkSession.builder.getOrCreate()

# create the Spark Context
sc = spark.sparkContext

## The program can take up to 3 minutes to run for the largest friend groups

# Takes in all the data and stores it into "data"
data = sc.textFile("soc-LiveJournal1Adj.txt")
print(data)

# Gets the input user ID from the keyboard and stores it in "id"
print("Input a user ID:")
id = input()

# Modifies the original data set in order to create pairs of user and freinds
# not including the input user.
# Ex: (0, 1), (0, 2), (0, 3)
dataMap = data.map(lambda x: x.split('\t'))
dataMap = dataMap.map(lambda x: [x[0], x[1].split(',')])
currPerson = dataMap.filter(lambda x: x[0] == id)
inputFriends = currPerson.flatMap(lambda x: x[1])
dataMapNoUser = dataMap.filter(lambda x: x[0] != id)
userPairs = dataMapNoUser.flatMapValues(lambda x: x)
userPairs = userPairs.filter(lambda x: x[1] != id)

# Creates a list of the users direct friends and their friends pairs. Had an
# issue of nested lists or RDD's, the nested for loop is used to solve that 
# and to make one neat list of all the direct friend pairs with their friends.
directFriends = []
directFriendsList = []
for x in inputFriends.collect():
  directFriends.append(userPairs.filter(lambda y: y[0] == x).collect())
directFriends = sc.parallelize(directFriends)
for x in directFriends.collect():
  for y in x:
    if y[0] != x:
      directFriendsList.append(y)
directFriendsList = sc.parallelize(directFriendsList)

# Creates a new list of friends of friends that appear on the input user's
# friends of friends list, but not on the input user's direct friend list.

# Appends to the list a new tuple of the user that is checked, and how many 
# times they appear in other user's friend's lists. If the friends appears
# 0 times, it is filtered out of the new list. 

# The nested for loop is designed to take the first friend that appears in the 
# list and go over the same list to count how many times they appear and return
# the result of (friend ID, appearances) to a new list.

# The first index of the new list of tuples is converted into ints in order to 
# sort from smallest to largest. The second index is then sorted from largest 
# to smallest to represent the most appearances to the least. The first 10 friends 
# that appear in the new list is taken and printed out to represent the top 10 
# mutual friends.
mutualCount = []
for x in directFriendsList.collect():
  z = 0
  for y in directFriendsList.collect():
    if(x[1] == y[1] and (x[1] not in inputFriends.collect())):
      z += 1
  if((int(x[1]),z) not in mutualCount and z!=0):
    mutualCount.append((int(x[1]), z))
  mutualCount.sort()
mutualCount = sc.parallelize(mutualCount)
mutualCount.filter(lambda x: x[1] != 0)
mutualCount = mutualCount.sortBy(lambda x: x[1], ascending = False)
mutualRecs = mutualCount.take(10)
print("Your top 10 mutual friends are:")
print(", ".join([str(x[0]) for x in mutualRecs]))